#!/usr/bin/env bash

vmBaseDir="$HOME/Documents/kvm/VMs"
vmDiskExt="img"
vmSystemType=$(uname -m)

vm_disk_create() {
  local vmName=$1
  local vmCreateGroup=$2
  local vmCreateDiskSize=$3

  local vmDisk="${vmBaseDir}/${vmCreateGroup}/${vmName}/${vmName}.${vmDiskExt}"
  if [ -f "${vmDisk}" ]
  then
    echo "${vmDisk}"
  else
    local vmDiskPath=$(dirname "${vmDisk}")
    mkdir -p "$vmDiskPath" || usage "unable to create ${vmDiskPath}"
    qemu-img create -q -f qcow2 "${vmDisk}" ${vmCreateDiskSize}G >/dev/null >&2
    ret=$?

    [ $ret -eq 0 ] && echo "${vmDisk}" || usage "unable to create ${vmDisk}"
  fi
}

vm_stop() {
  local vmName=$1
  local vmGroup=$2

  subGroupDir="${vmBaseDir}/${groupName}"
  pkill -f qemu-system-${vmSystemType} | sed -r ":file=${subGroupDir}/${vmName}/:!d"
}

vm_run() {
  local vmName=$1
  local vmGroup=$2
  local isoName=$3
  local guiOpt=$4

  local isoOpt="-cdrom ${isoDir}/${isoName}"
  [ "${isoName} " == "none " ] && isoOpt=""

  local vmNoGui="-display sdl -no-quit"
  [ "${guiOpt} " == "gui " ] || vmNoGui="--display none"

  [ -f "${vmBaseDir}/${vmGroup}/${vmName}/${vmName}.conf" ] && . "${vmBaseDir}/${vmGroup}/${vmName}/${vmName}.conf"

  net_up_cloudme

  [ ${vmGroup} != ${vmCreateGroup} ] && vmMac=$(vm_mac ${vmName}) || vmMac="00:00:11:22:33:44"
  qemu-system-${vmSystemType} \
    -enable-kvm \
    ${isoOpt} \
    -boot order=d \
    -drive file="${vmDisk}",format=qcow2 \
    -smp cpus=1,cores=${vmCpu},maxcpus=${vmCpu} \
    -m ${vmMem} \
    -name ${vmName} \
    -D "${vmBaseDir}/${vmGroup}/${vmName}/${vmName}.log" \
    --daemonize \
    ${vmNoGui} \
    -net nic,model=virtio,macaddr=${vmMac} -net bridge,br=${bridgeInterface}
    >/dev/null 2>&1
}

vm_mac() {
  vmName=$1

  echo ${vmName} | sed -r 's/-//g;s/^(.{8}).*/0000\1/;s/(..)/\1:/g;s/:$//'
}

vm_create() {
  local vmName=$1
  local vmGroup=$2
  local isoName=$3

  local vmDisk="${vmBaseDir}/${vmGroup}/${vmName}/${vmName}.${vmDiskExt}"
  [ -f "${vmDisk}" ] || ${vmDisk}="$(vm_disk_create ${vmName} ${vmGroup} ${vmCreateDiskSize})"
  vm_run ${vmName} ${vmGroup} "${isoName}" gui
}

vm_clone_disk() {
  local vmSrcGroup=$1
  local vmSrc=$2
  local vmDestGroup=$3
  local vmDest=$4

  local vmSrcDir="${vmBaseDir}/${vmSrcGroup}/${vmSrc}"
  local vmSrcCount=$(ps -A -o args | grep qemu-system-${vmSystemType} | grep -v grep | grep "${vmSrcDir}/" | wc -l)
  [ ${vmSrcCount} -ne 0 ] && usage "can't clone a running vm"
  . ${vmSrcDir}/${vmSrc}.conf
  [ -f "${vmDisk}" ] || usage "can't clone non-existing disk ${vmSrcDisk}"
  chmod a-w "${vmDisk}"
  local vmDestDir="${vmBaseDir}/${vmDestGroup}/${vmDest}"
  local vmDestDisk="${vmDestDir}/${vmDest}.${vmDiskExt}"
  mkdir -p "${vmDestDir}" || usage "unable to create ${vmDestDir}"
  qemu-img create -q -f qcow2 -b "${vmDisk}" "${vmDestDisk}" >/dev/null >&2
  echo "${vmDestDisk}"
}

vm_running() {
  local groupName="$1"
  local subGroupName="$2"

  [ "${groupName}" == "*" ] && groupName='[^/]*'
  [ "${subGroupName}" == "*" ] && subGroupName='[^/]*'
  subGroupDir="${vmBaseDir}/${groupName}/${subGroupName}"
  
  for vmPath in $(pgrep -f qemu-system-${vmSystemType} -a | sed -r ":file=${subGroupDir}/:!d;s:^.* file\=${vmBaseDir}/::;s:/[^/]+,.*::")
  do
    vmName=$(echo ${vmPath} | sed -r 's:.*/([^/]+)$:\1:')
    vmGroup=$(echo ${vmPath} | sed -r "s:/${vmName}::")
    vmMac=$(vm_mac ${vmName})
    vmIP=$(grep " ${vmMac} " /var/lib/misc/dnsmasq.leases | cut -d " " -f 3)
    echo ${vmName} ${vmGroup} ${vmIP}
  done
}

is_vm_running() {
  local vmName=$1

  vmIsRunning=$(vm_running | grep "^${vmName} " | wc -l)
  echo ${vmIsRunning}
}

vm_ssh() {
  local vmIp=$1
  shift

  sshTry=0
  sshTryMax=30
  while [ ${sshTry} -le ${sshTryMax} ]
  do
    ssh -i ${realDir}/.ssh_key.pub -o strictHostKeyChecking=false root@${vmIp} true >/dev/null 2>&1 && break
    sleep 1
    sshTry=$((${sshTry}+1))
  done
  [ ${sshTry} -gt ${sshTryMax} ] && return 1
  ssh -i ${realDir}/.ssh_key.pub root@${vmIp} $@
}

vm_ip() {
  local vmName=$1

  vmIp=
  ipFindingIteration=0
  ipFindingIterationMax=30
  while [ ${ipFindingIteration} -le ${ipFindingIterationMax} ]
  do
    vmIp=$(vm_running | grep ^${vmName} | cut -d ' ' -f 3)
    [ -n "${vmIp}" ] && break
    sleep 1
    ipFindingIteration=$((${ipFindingIteration}+1))
  done
  [ ${ipFindingIteration} -gt ${ipFindingIterationMax} ] && return 1
  echo $vmIp
}

net_up_cloudme() {
  if [ ! -d /etc/qemu ] ; then
    sudo mkdir /etc/qemu
    sudo chown root:kvm /etc/qemu
    sudo chmod 750 /etc/qemu
  fi
  if [ ! -f /etc/qemu/bridge.conf ] ; then
    sudo touch /etc/qemu/bridge.conf
    sudo chown root:kvm /etc/qemu/bridge.conf
    sudo chmod 640 /etc/qemu/bridge.conf
  fi
  grep "allow all" /etc/qemu/bridge.conf >/dev/null 2>&1 || echo "allow all" | sudo tee --append /etc/qemu/bridge.conf >/dev/null

  bridgeInterfaceUp=$(ip link | sed -r '/^[0-9]+:/!d;s/[0-9]+: ([^:]+):.*/\1/' | grep -c "^${bridgeInterface}$")
  if [ ${bridgeInterfaceUp} -eq 0 ] ; then
    sudo ip link add name ${bridgeInterface} type bridge
    sudo ip link set ${bridgeInterface} up
    sudo ip addr add ${bridgeAddress} dev ${bridgeInterface}
    sudo iptables -I INPUT -i ${bridgeInterface} -j ACCEPT
    sudo iptables -A fw-interfaces -i ${bridgeInterface} -j ACCEPT
    sudo iptables -t nat -A POSTROUTING -s ${bridgeNet} -o ${netInterface} -j MASQUERADE
    sudo sysctl -q net.bridge.bridge-nf-call-ip6tables=0
    sudo sysctl -q net.bridge.bridge-nf-call-iptables=0
    sudo sysctl -q net.bridge.bridge-nf-call-arptables=0
    sudo dnsmasq --interface=bridge0 --bind-interfaces --dhcp-range=${bridgeDhcpStart},${bridgeDhcpStop}
  fi
}

net_down_cloudme() {
  sudo sysctl -q net.bridge.bridge-nf-call-ip6tables=1
  sudo sysctl -q net.bridge.bridge-nf-call-iptables=1
  sudo sysctl -q net.bridge.bridge-nf-call-arptables=1
  sudo systemctl restart iptables
  sudo killall dnsmasq
  sudo ip link delete dev bridge0
}


