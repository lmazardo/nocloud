#!/usr/bin/env bash

vmBaseDir="$HOME/Documents/kvm/VMs"
vmDiskExt="img"
vmSystemType=$(uname -m)

vm_disk_create() {
  local vmName=$1
  local vmCreateGroup=$2
  local vmCreateDiskSize=$3

  local vmDisk="${vmBaseDir}/${vmCreateGroup}/${vmName}/${vmName}.${vmDiskExt}"
  if [ -f "${vmDisk}" ]
  then
    echo "${vmDisk}"
  else
    local vmDiskPath=$(dirname "${vmDisk}")
    mkdir -p "$vmDiskPath" || usage "unable to create ${vmDiskPath}"
    qemu-img create -q -f qcow2 "${vmDisk}" ${vmCreateDiskSize}G >/dev/null >&2
    ret=$?

    [ $ret -eq 0 ] && echo "${vmDisk}" || usage "unable to create ${vmDisk}"
  fi
}

vm_stop() {
  local vmName=$1
  local vmGroup=$2

  subGroupDir="${vmBaseDir}/${groupName}"
  pkill -f qemu-system-${vmSystemType} | sed -r ":file=${subGroupDir}/${vmName}/:!d"
}

vm_run() {
  local vmName=$1
  local vmGroup=$2
  local isoName=$3
  local guiOpt=$4

  local isoOpt="-cdrom ${isoDir}/${isoName}"
  [ "${isoName} " == "none " ] && isoOpt=""

  local vmNoGui="-display sdl -no-quit"
  [ "${guiOpt} " == "gui " ] || vmNoGui="--display none"

  [ -f "${vmBaseDir}/${vmGroup}/${vmName}/${vmName}.conf" ] && . "${vmBaseDir}/${vmGroup}/${vmName}/${vmName}.conf"

  [ ${vmGroup} != ${vmCreateGroup} ] && vmMac=$(vm_mac ${vmName}) || vmMac="00:00:11:22:33:44"
  qemu-system-${vmSystemType} \
    -enable-kvm \
    ${isoOpt} \
    -boot order=d \
    -drive file="${vmDisk}",format=qcow2 \
    -smp cpus=1,cores=${vmCpu},maxcpus=${vmCpu} \
    -m ${vmMem} \
    -name ${vmName} \
    -D "${vmBaseDir}/${vmGroup}/${vmName}/${vmName}.log" \
    --daemonize \
    ${vmNoGui} \
    -net nic,model=virtio,macaddr=${vmMac} -net bridge,br=${bridgeInterface}
    >/dev/null 2>&1
}

vm_mac() {
  vmName=$1

  echo ${vmName} | sed -r 's/-//g;s/^(.{8}).*/0000\1/;s/(..)/\1:/g;s/:$//'
}

vm_create() {
  local vmName=$1
  local vmGroup=$2
  local isoName=$3

  local vmDisk="${vmBaseDir}/${vmGroup}/${vmName}/${vmName}.${vmDiskExt}"
  [ -f "${vmDisk}" ] || ${vmDisk}="$(vm_disk_create ${vmName} ${vmGroup} ${vmCreateDiskSize})"
  vm_run ${vmName} ${vmGroup} "${isoName}" gui
}

vm_clone_disk() {
  local vmSrcGroup=$1
  local vmSrc=$2
  local vmDestGroup=$3
  local vmDest=$4

  local vmSrcDir="${vmBaseDir}/${vmSrcGroup}/${vmSrc}"
  local vmSrcCount=$(ps -A -o args | grep qemu-system-${vmSystemType} | grep -v grep | grep "${vmSrcDir}/" | wc -l)
  [ ${vmSrcCount} -ne 0 ] && usage "can't clone a running vm"
  . ${vmSrcDir}/${vmSrc}.conf
  [ -f "${vmDisk}" ] || usage "can't clone non-existing disk ${vmSrcDisk}"
  chmod a-w "${vmDisk}"
  local vmDestDir="${vmBaseDir}/${vmDestGroup}/${vmDest}"
  local vmDestDisk="${vmDestDir}/${vmDest}.${vmDiskExt}"
  mkdir -p "${vmDestDir}" || usage "unable to create ${vmDestDir}"
  qemu-img create -q -f qcow2 -b "${vmDisk}" "${vmDestDisk}" >/dev/null >&2
  echo "${vmDestDisk}"
}

vm_running() {
  local groupName="$1"
  local subGroupName="$2"

  [ "${groupName}" == "*" ] && groupName='[^/]*'
  [ "${subGroupName}" == "*" ] && subGroupName='[^/]*'
  subGroupDir="${vmBaseDir}/${groupName}/${subGroupName}"
  
  for vmPath in $(pgrep -f qemu-system-${vmSystemType} -a | sed -r ":file=${subGroupDir}/:!d;s:^.* file\=${vmBaseDir}/::;s:/[^/]+,.*::")
  do
    vmName=$(echo ${vmPath} | sed -r 's:.*/([^/]+)$:\1:')
    vmGroup=$(echo ${vmPath} | sed -r "s:/${vmName}::")
    vmMac=$(vm_mac ${vmName})
    vmIP=$(grep " ${vmMac} " /var/lib/misc/dnsmasq.leases | cut -d " " -f 3)
    echo ${vmName} ${vmGroup} ${vmIP}
  done
}

vm_instantiate() {
  local vmTemplate=$1
  local vmCount=$2
  local vmGroup=$3
  local vmSubGroup=$4

  [ -z ${vmGroup} ] && vmGroup=${vmDefaultGroup}
  [ -z ${vmSubGroup} ] && vmSubGroup=${vmDefaultSubGroup}

  local vmTemplateGroup=${vmCreateGroup}
  . <(sed 's/^/tmplt_/' ${vmBaseDir}/${vmTemplateGroup}/${vmTemplate}/${vmTemplate}.conf)

  local vmList=
  local vmDir=${vmBaseDir}/${vmGroup}/${vmSubGroup}
  for vmNum in $(seq 1 ${vmCount})
  do
    local vmName=$(uuidgen)
    [ -f ${vmDir}/${vmName} ] || mkdir -p ${vmDir}/${vmName}
    local vmDisk=$(vm_clone_disk ${vmTemplateGroup} ${vmTemplate} ${vmGroup}/${vmSubGroup} ${vmName})
    cat > ${vmDir}/${vmName}/${vmName}.conf <<EOF
vmName=${vmName}
vmMem=${tmplt_vmMem}
vmCpu=${tmplt_vmCpu}
vmDisk=${vmDisk}
EOF
    vm_run ${vmName} ${vmGroup}/${vmSubGroup} none
    vmList="${vmList} ${vmName}"
  done

  for vmName in ${vmList}
  do
    vm_ssh $(vm_ip ${vmName}) -o strictHostKeyChecking=false "echo ${vmName} > /etc/hostname ; hostname -F /etc/hostname ; reboot" >/dev/null 2>&1 &
  done

  #wait

  for vmName in $vmList
  do
    echo ${vmName}
  done
}

is_vm_running() {
  local vmName=$1

  vmIsRunning=$(vm_running | grep "^${vmName} " | wc -l)
  echo ${vmIsRunning}
}

vm_ssh() {
  local vmIp=$1
  shift

  sshTry=0
  sshTryMax=30
  while [ ${sshTry} -le ${sshTryMax} ]
  do
    ssh -i ${realDir}/.ssh_key.pub -o strictHostKeyChecking=false root@${vmIp} true >/dev/null 2>&1 && break
    sleep 1
    sshTry=$((${sshTry}+1))
  done
  [ ${sshTry} -gt ${sshTryMax} ] && return 1
  ssh -i ${realDir}/.ssh_key.pub root@${vmIp} $@
}

vm_ip() {
  local vmName=$1

  vmIp=
  ipFindingIteration=0
  ipFindingIterationMax=30
  while [ ${ipFindingIteration} -le ${ipFindingIterationMax} ]
  do
    vmIp=$(vm_running | grep ^${vmName} | cut -d ' ' -f 3)
    [ -n "${vmIp}" ] && break
    sleep 1
    ipFindingIteration=$((${ipFindingIteration}+1))
  done
  [ ${ipFindingIteration} -gt ${ipFindingIterationMax} ] && return 1
  echo $vmIp
}
